namespace apache {
    class output {
        var writer;
        var request;
        var buffer;
        var headerWriter;

        function output(var request) {
            self.request = request;
            self.writer = dlfunc(null, "mod_parrot_write", "ipip");
            self.headerWriter = dlfunc(null, "mod_parrot_header_out", "vPPPp");
            self.buffer = new ByteBuffer; // warn then, I dare you
        }

        function puts(string msg) {
            var writer = self.writer;
            self.buffer =: msg;
            return writer(self.buffer, elements(self.buffer), self.request);
        }


        function header(string key, string value) {
            var writer = self.headerWriter;
            writer(getinterp(), key, value, self.request);
        }

        function headers(var headers) {
            for(var k in headers) {
                self.header(k, headers[k]);
            }
        }
    }   
    
    class input {
        var reader;
        var headerReader;
        var requestReader;
        var setup;
        var request;
        var remaining;
        var bytesRead;
        var buffer;
        var readSize;
        
        function input(var request) {
            self.request = request;
            self.reader = dlfunc(null, "mod_parrot_read", "ipip");
            self.headerReader = dlfunc(null, "mod_parrot_headers_in", "PPp");
            self.requestReader = dlfunc(null, "mod_parrot_request_parameters", "PPp");
            self.buffer = new ByteBuffer;
            self.readSize = 16; // this should be configurable 
            self.remaining = self.bytesRead = -1;
        }

        function setup() {
            var setupFunc = dlfunc(null, "mod_parrot_setup_input", "ip");
            self.remaining = setupFunc(request);
        }
        
        function readline() {
            // until we have a buffering system, do not implement this.
            // it isn't all that sensible, after all
        }

        function readall() {
            var builder = new StringBuilder;
            while(self.remaining > 0) {
                string msg = self.read(self.readSize);
                push(builder, msg);
            }
            return string(builder);
        }

        function read(int size) {
            if(self.bytesRead < 0) {
                
            }
            self.buffer =: size;
            var reader = self.reader;
            int readBytes = reader(self.buffer, size, self.request);
            if(readBytes > 0) {
                self.remaining -= readBytes;
                return self.buffer.get_chars(0, readBytes, "binary");
            } else {
                self.remaining = 0;
                return "";
            }
        }
        
        function headers() {
            var reader = self.headerReader;
            return reader(getinterp(), self.request);
        }

        function request() {
            var reader = self.requestReader;
            return reader(getinterp(), self.request);
        }
    }

    function setup[main](var request) {
        getinterp().stdin_handle(new input(request));
        getinterp().stdout_handle(new output(request));            
    }
}
